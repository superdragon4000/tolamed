# Backend Test Task

Полная постановка задания находится в [TASK.md](./TASK.md).

## Быстрый старт

```bash
docker compose up --build
```

API: `http://localhost:3000`

## Полезные команды

```bash
docker compose exec api npm run migrate
docker compose exec api npm test
docker compose down -v
```

## Что сдавать

- ссылка на репозиторий или ветку с изменениями;
- обновлённый `README.md` с разделом `Анализ и рефакторинг` (ответы на 7 вопросов из `TASK.md`);
- инструкция запуска тестов и подтверждение, что обязательные сценарии проходят.

## Запуск тестов

Внутри контейнера API тесты запускаются так:

```bash
npm test
```

Если инфраструктура уже поднята через Docker Compose, удобно запускать так:

```bash
docker compose exec api npm test
```

Покрываемые обязательные сценарии:

- duplicate request для `POST /users/:id/spend` не приводит к двойному списанию;
- expired accrual не участвует в доступном балансе;
- одновременные списания не нарушают консистентность баланса;
- постановка и повторный запуск job `expire-accruals` работают корректно.

## Анализ и рефакторинг

### 1) Какие проблемы были в текущей реализации

- Списание (`spend`) выполнялось без надёжной идемпотентности на уровне БД.
- При конкурентных запросах были возможны гонки и неконсистентный результат.
- Не учитывалась уникальность `(user_id, request_id)` для списаний.
- `requestId` не валидировался и мог использоваться некорректно.

### 2) Какие изменения внесены для корректности списаний и защиты от гонок

- Операции списания выполняются в транзакции.
- Для сериализации операций на пользователя используется advisory lock (`pg_advisory_xact_lock(hashtext(userId))`).
- Добавлена уникальность `(user_id, request_id)` для `spend`-операций.
- Логика обработки конфликтов выполняется на уровне БД и приложения.

### 3) Что сделано для идемпотентности `POST /users/:id/spend`

На уровне БД:

- добавлен уникальный индекс для `spend` по `(user_id, request_id)`;
- поле `request_id` используется как ключ идемпотентности.

На уровне API:

- принимаются `amount` и обязательный `requestId`;
- поддерживается `Idempotency-Key` (или `body.requestId`);
- возвращается `409`, если `requestId` уже использован с другим payload;
- возвращается `400` при невалидном запросе.

### 4) Как обрабатывается duplicate request

- Повторный запрос определяется по ключу идемпотентности (`Idempotency-Key` или `requestId`).
- В БД повторная запись блокируется уникальным индексом.
- Если payload совпадает, возвращается успешный ответ без повторного списания.
- Если payload отличается, возвращается `409`.

### 5) Как гарантируется, что expired accrual не участвует в балансе

- В расчёте доступного баланса участвуют только `accrual` с `expires_at IS NULL OR expires_at >= NOW()`.
- Истёкшие начисления не учитываются при проверке возможности списания.

### 6) Как организован job expire-accruals

- `POST /jobs/expire-accruals` ставит задачу в очередь (`jobId: "expire-accruals"`).
- Для job настроены повторы (`attempts`) и backoff.
- Worker запускает `expireAccruals` и формирует компенсирующие операции для истёкших начислений.
- Для защиты от дублей используется идемпотентный ключ и `ON CONFLICT DO NOTHING`.

### 7) Почему выбран именно такой подход

- Ключевая бизнес-гарантия обеспечивается на уровне БД, а не только на уровне приложения.
- Advisory lock даёт предсказуемое поведение при высокой конкуренции по одному пользователю.
- Идемпотентность через `request_id` и уникальный индекс делает повторные запросы безопасными.
