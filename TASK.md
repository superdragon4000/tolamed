# Тестовое задание: Backend (Node.js + TypeScript)

Проект находится в стадии активного развития и содержит технический долг.  
Нам важно понять, как вы работаете с существующим старым кодом, параллельными запросами и асинхронной обработкой через очередь.

## Ограничение по времени

`4–6 часов`

Важно: не требуется полное переписывание архитектуры, внедрение DDD или сложных паттернов.

## Стек

- Node.js
- TypeScript
- Express
- PostgreSQL
- Sequelize
- BullMQ
- Redis
- Docker Compose

## Контекст

В проекте уже есть существующая старая реализация бонусов, которая намеренно наивная.

Проблемные зоны:

- списание бонусов (`POST /users/:id/spend`)
- обработка задач очереди (`POST /jobs/expire-accruals`)

## Что нужно сделать

### 1) Исправить списание бонусов

Реализуйте корректное списание бонусов с учетом параллельных запросов и защиты от повторной обработки одного и того же запроса.

Обязательные требования:

- просроченное начисление (`expired accrual`) не участвует в балансе;
- повторный одинаковый запрос (`duplicate request`) не создает повторное списание;
- баланс не может уходить в минус при конкурентных запросах;
- решение должно быть безопасно при параллельных вызовах `POST /users/:id/spend`.

Требование к защите от повтора запроса:

- используйте идентификатор запроса (`requestId` в body или `Idempotency-Key` в header);
- повтор того же запроса с тем же идентификатором не должен приводить к новой транзакции списания.

Контракт `POST /users/:id/spend` (обязателен):

- `requestId` обязателен: берется из `body.requestId` или `Idempotency-Key` header;
- если переданы оба варианта, используйте `Idempotency-Key` header;
- область идемпотентности: `(user_id, requestId)`, а не глобально по всем пользователям.

Ожидаемые ответы:

- `200` для первого успешного списания:
  - `{ "success": true, "duplicated": false }`
- `200` для повтора того же запроса (тот же `user_id` + `requestId` + тот же payload):
  - `{ "success": true, "duplicated": true }`
- `409` если тот же `requestId` уже использован для того же `user_id`, но с другим payload;
- `400` для невалидного payload или недостаточного баланса.

### 2) Реализовать рабочую обработку очереди

Сейчас очередь подключена, но фактически не обрабатывает бизнес-логику.  
Нужно реализовать обработчик `expireAccruals` так, чтобы он делал полезную работу с данными.

Обязательные требования:

- endpoint `POST /jobs/expire-accruals` ставит job с предсказуемым `jobId` (`expire-accruals`);
- worker находит `accrual`, у которых `expires_at < NOW()`;
- для каждого такого начисления создается `spend`-транзакция на ту же сумму с `request_id = "expire:<accrual_id>"`;
- если `spend` с таким `request_id` уже есть, повторно его создавать нельзя;
- добавить retry для временных ошибок: минимум `attempts: 3` и `backoff` (не меньше 1000мс);
- повторная постановка и повторная обработка не должны давать дубли бизнес-эффекта.

### 3) Добавить тесты

Добавьте автоматизированные тесты, которые проверяют ключевую корректность.

Минимум обязательных сценариев:

1. Повторный запрос на списание с тем же `requestId` не создает второе списание.
2. Начисление с истекшим сроком действия (`accrual`) не учитывается в доступном балансе.
3. Конкурентные списания не приводят к отрицательному балансу/двойному списанию сверх доступного.
4. Очередь: повторная обработка/повторная постановка задачи не создает дубли бизнес-эффектов.

Тестовый раннер: `Jest`.
Тесты должны запускаться одной командой (`npm test`).

Для формата `4–6 часов` достаточно реализовать и покрыть тестами только эти обязательные сценарии, без дополнительного расширения фич.

## Обязательная часть: Анализ и рефакторинг

В `README.md` добавьте раздел `Анализ и рефакторинг` и обязательно ответьте на вопросы:

1. Какие проблемы были в исходной реализации списания?
2. Какие проблемы при одновременных запросах вы устранили и как именно?
3. Какие обязательные правила корректности вы обеспечили на уровне БД и на уровне кода?
4. Как реализована защита от повторного одинакового запроса (`duplicate request`)?
5. Как обеспечено, что просроченное начисление (`expired accrual`) не участвует в балансе?
6. Как реализована надежная обработка очереди (повторные попытки, паузы, защита от дублей)?
7. Какие компромиссы вы приняли в рамках ограничения `4–6 часов`?

Ответы обязательны. Без них задание считается неполным.

## Критерии оценки

- корректность итогового поведения и консистентность данных;
- понимание работы с одновременными запросами и транзакциями;
- качество реализации очереди (асинхронность, надежность, защита от повторного эффекта);
- наличие и качество тестов на критичные сценарии;
- аргументированность инженерных компромиссов;
- аккуратность изменений в существующем коде.

## Ограничения

Не требуется:

- полностью переписывать архитектуру;
- внедрять DDD;
- добавлять сложные паттерны ради паттернов.

По миграциям:

- существующие миграции редактировать не нужно;
- если нужны изменения схемы, добавьте новую миграцию.

Оценивается инженерное мышление, качество анализа и надежность практической реализации.

## Формат сдачи

- ссылка на репозиторий/ветку с изменениями;
- обновленный `README.md` с анализом и описанием принятых решений;
- инструкция запуска тестов и подтверждение, что ключевые сценарии проходят.
